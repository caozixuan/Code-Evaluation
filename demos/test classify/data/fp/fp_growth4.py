# -*- coding: utf-8 -*-import get_data as gimport datetimetimes = 1class FPTreeNode():	def __init__(self, name):		self.name = name		self.count = 0		self.parent = None		self.children = []		self.link = None		self.tail = None	# since self's next link isn't also equal to it tail,    # 'self.tail' is defined to find the tail of the link list quickly.	def add_child(self, child):		self.children.append(child)	def find_child(self, name):		for child in self.children:			if child.name == name:				return child		return Noneclass FPGrowth():	def __init__(self, data_set, support):		self.data_set = data_set		self.support = support		self.freq_item_sets = []  # freq_item_sets: (itemset, frequency) tuple	def __get_freq(self, transactions):		"""Get item-frequency pairs dictionary."""		item_freq_dic = {}		for transaction in transactions:			for item in transaction:				item_freq_dic[item] = \					item_freq_dic.get(item, 0) + 1  # 0 is default value		return item_freq_dic	def build_fptree(self):		if self.data_set is None:			return		# get 1-item set		freq_dic_1_item = self.__get_freq(self.data_set)		# sort items in descending order making it easy to build tree from root		self.__sort_items(freq_dic_1_item, self.data_set)		# begin build FP-tree		# At first, cpb is data set, post pattern is none.		self.__fpgrowth(self.data_set, [])		# sort frequent item sets		self.freq_item_sets.sort(key=lambda x: len(x[0]), reverse=False)	def __sort_items(self, freq_dic, trans_records):		"""Sort items in descending order.		Parameters:		freq_dic - item-frequency pairs dictionary.		Since dict can't be sorted, we should use a tmp list to sort items.		Then use items' order to sort items in each transaction of dataset.		Lambda exp: sort the item list by item frequencies.		"""		tmp_list = []		tmp_list.extend(freq_dic.keys())  # add items to list		tmp_list.sort(key=lambda x: freq_dic[x])		tmp_dict = {}		i = 1		for item in tmp_list:			tmp_dict[item] = i			i += 1		for transaction in trans_records:			transaction.sort(key=lambda x: tmp_dict[x], reverse=True)	def __sort_dict(self, dict):		"""Sort dict according to values in descending order.		Since dict can't be sorted, we should use a tmp list to sort items.		"""		tmp_list = []		tmp_list.extend(dict.keys())  # add items to list		tmp_list.sort(key=lambda x: dict[x])		tmp_dict = {}		for item in tmp_list:			tmp_dict[item] = dict[item]		return tmp_dict	def __fpgrowth(self, cpb, post_pattern):		"""Recursive function to mining fp-tree.		Parameters:		cpb - condition pattern base.		post_pattern - post pattern of frequent set.		The recursion ends when the condition FP-tree's root has no children.		"""		# test log begin ==========================		global times		print  "="*50		print "recursion times: %d" %times		times += 1		print "current cpb:", cpb		print "current post pattern:", post_pattern		# test log end ============================		# create headers table with tuple list (since tuple has order)		# header is item-node tuple		item_freq_dic = self.__get_freq(cpb)		print "item-frequency pairs dictionary:", item_freq_dic		item_freq_list = sorted(item_freq_dic.items(),							key=lambda x: (x[1]), reverse=True)		print "item-frequency tuple list:", item_freq_list		trans_num = float(len(self.data_set))		headers = []		for pair in item_freq_list:  # pair[0]: item name, pair[1]: item frequency			# !! if a item's support smaller than mini support, remove it.			if pair[1] / trans_num >= self.support:				node = FPTreeNode(pair[0])				node.count = pair[1]				header = (pair[0], node)  # item-node tuple				headers.append(header)  # tuple list		# crete condition FP-tree from each cpb		tree_root = self.__build_subtree(cpb, headers)		if len(tree_root.children) == 0:  # condition for ending recursion			return		# create post pattern from condition FP-tree		for header in reversed(headers):  # !! mining header in reverse order			header_node = header[1]  # item's node			# create frequent item set			itemset = []  # item set is header_node + post_pattern			itemset.append(header_node.name)			itemset.extend(post_pattern)			tmp_set = (itemset, header_node.count / trans_num)			self.freq_item_sets.append(tmp_set)			# create post pattern			new_post_pattern = itemset  # same operation as creating itemset			# create condition pattern base (cpb)			# new cpb is specific for one header_node (current node)			# a cpb is a path from root to current node(except for current node)			new_cpb = []			next_node = header_node			while True:				next_node = next_node.link  # continue for next node				if next_node is None:  # end condition for while					break				count = next_node.count # count for times of adding transaction.				# find path per node				# path starts from current node's parent to root,				# and then reverse!				path = []				parent = next_node.parent				while True:					if parent.name is None:  # end condition for while						break					path.append(parent.name)  # node name is item					parent = parent.parent				path.reverse()				# transactions(path) should be added 'count' times.				for _ in range(count):					new_cpb.append(path)			# mining for each header_node			self.__fpgrowth(new_cpb, new_post_pattern)	def __build_subtree(self, transactions, headers):		"""Build sub FP-tree.		Add node per transaction item, if one node is added,		pop the corresponding item from the transaction, do loop until all items		are popped and all transacations have been traversed.		If sub_root has the same child node as the		first transaction node(record[0]),		consider the child node as sub_root and		bulid sub_tree on it, and do loop.		If sub_root doesn't have, add node from the parent root.		Returns:		root - FP-tree's root , you can traverse the whole tree from the root.		"""		# root: null node		root = FPTreeNode(None)  # name = None		for trans in transactions:  # add node per transcarion			record = []			record.extend(trans)			sub_root = root			tmpRoot = None			if len(root.children) != 0:				while len(record) != 0:  # find same item node to add child node					tmpRoot = sub_root.find_child(record[0])					# end finding, and will add child node on current sub_root					if tmpRoot is None:						break					sub_root = tmpRoot  # continue finding new sub_root					# see as add same item node on tmpRoot.					tmpRoot.count += 1					record.pop(0)			self.__add_nodes(sub_root, record, headers)		return root	def __add_nodes(self, parent, record, headers):		"""Add nodes from parent one item by one item.		Finish adding nodes util all items in the record have been added and removed from the record.		"""		while len(record) > 0:			item = record.pop(0)  # add node and remove it from record			for header in headers:				head_node = header[1]  # item's node				if item == head_node.name:					# create node and init it.					new_node = FPTreeNode(item)					new_node.count = 1					new_node.parent = parent					parent.add_child(new_node)					if head_node.link is None:						head_node.link = new_node					else: head_node.tail.link = new_node					head_node.tail = new_node					self.__add_nodes(new_node, record, headers)if __name__== "__main__":	starttime = datetime.datetime.now()	print "FP-Growth algorithm begin"+"="*20	data_set = g.get_data()	support = 0.4	fp = FPGrowth(data_set, support)	fp.build_fptree()	freq_item_sets = fp.freq_item_sets	print "item set", "\t\t", "frequency ratio"	print "="*50	for pair in freq_item_sets:		print pair[0], "\t\t", pair[1]	print "="*50	print "FP-Growth algorithm end"+"="*20	endtime = datetime.datetime.now()	print "use time: ", (endtime - starttime).seconds